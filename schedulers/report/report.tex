\documentclass{acm_proc_article-sp}

\begin{document}

\title{CS211 Assignment 2: Scheduling}
\numberofauthors{1}
\author{
  \alignauthor 
  Samuel B Sherar\\
  \email{sbs1@aber.ac.uk}\
}

\maketitle

\section{Introduction}
In this report I will be analysing the effects of 4 different scheduling algorithms: First In First Out, Shortest Time Remaining, Round Robin \& Lottery Schedulers. During my experiments, I will be conducting tests on different sized datasets and then analysing different aspects of the environment, such as Idle time, Context switching and mean time for an average job.

%TODO extend and expand
\section{Implementation}

\subsection{Round Robin Scheduler}

To implement the Round Robin scheduler, we can utilise the First Come First Served scheduler given, but modifying a couple of key aspects. The first thing to do was change the \texttt{ArrayList} to a \texttt{LinkedList} to gauruntee that the returned job will always be entered at the end. We can also add 2 class scoped variables, one specifying the amount of cycles before removing the job at the head of the queue, and one to count how many cycles it has been since we started the job. The main reason for this to create a single edit point, instead of hard coding it so it is easier to analyse the difference between different cycle counts.

\subsection{Shortest Time Remaining Scheduler}

The way I created the Shortest Time Remaining algorithm was to check the time remaining when adding the job to the queue by retrieving the \texttt{Job.length()} minus \texttt{Job.get\-ProgramCount()}. Using the documentation I wanted to use \texttt{Job.getElapsedTime()}, but during debugging my code, it seemed to return 0 constantly, and therefore not suitable to get consistant results.

\subsection{Lottery Scheduler}

As a worst case scenario, I decided to implement the lottery scheduler. I did this by every time a job is returned from processing, I use \texttt{Collections.shuffle} while using my own object for the randomness. This means that each run I can change the seed to the current milliseconds currently elapsed from the UNIX epoch, and therefore stop issues arising when running the algorithm than more than 1 time.

\section{Method}

To gather a good amount of data, I will be running each algorithm through 3 different datasets: one which was given to me with the scheduler, which has a mix of CPU, I/O blocked and mix of the two; another data file 500 instructions in total across multiple processess, and the last file with 10,000 instructions. 

For unbiased results with the Lottery Scheduler, I will be running it through each dataset 10 times and applying Standard Deviation to the results to remove any anomalies. This will give me a better mean and average across all the results.

\section{Test Constraints}

\section{Results}

\subsection{Fasted Job Completion}

\subsection{Idle Time}

\subsection{Mean Time}

\subsection{Context Switching}

\section{Conclusion}



\end{document}
