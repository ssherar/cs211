\documentclass{acm_proc_article-sp}

\begin{document}

\title{CS211 Assignment 2: Scheduling}
\numberofauthors{1}
\author{
  \alignauthor 
  Samuel B Sherar\\
  \email{sbs1@aber.ac.uk}\
}

\maketitle

\section{Introduction}
In this report I will be analysing the effects of 4 different scheduling algorithms: First In First Out, Shortest Time Remaining, Round Robin \& Lottery Schedulers. During my experiments, I will be conducting tests on different sized datasets and then analysing different aspects of the environment, such as Idle time, Context switching and mean time for an average job.

The analysis of a scheduling algorithm is important 

%TODO extend and expand
\section{Implementation}

When implementing the algorithms, each algorithm was created and tested on each given test file and stepped through to check the implementation was doing as expected. This means that when the additional data files with the larger amount of instructions will run without errors, which might be lost when run through such a large amounts of data.

\subsection{Round Robin Scheduler}

To implement the Round Robin scheduler, we can utilise the First Come First Served scheduler given, but modifying a couple of key aspects. The first thing to do was change the \texttt{ArrayList} to a \texttt{LinkedList} to gauruntee that the returned job will always be entered at the end. We can also add 2 class scoped variables, one specifying the amount of cycles before removing the job at the head of the queue, and one to count how many cycles it has been since we started the job. The main reason for this to create a single edit point, instead of hard coding it so it is easier to analyse the difference between different cycle counts.

\subsection{Shortest Time Remaining Scheduler}

To create the Shortest Time Remaining algorithm, the idea was to check the time remaining when adding the job to the queue by retrieving the \texttt{Job.length()} minus \texttt{Job.get\-ProgramCount()}. Using the documentation I wanted to use \texttt{Job.getElapsedTime()}, but during debugging my code, it seemed to return 0 constantly, and therefore not suitable to get consistent results.

\subsection{Lottery Scheduler}

The lottery scheduler was implemented as a worst case senario. This was done by every time a job is returned from processing,\texttt{Collections.shuffle} randomised the queue  while using a specified random class for the randomness. This means that each time it was run, the seed was changed to the current milliseconds currently elapsed from the UNIX epoch, and therefore stop issues arising when running the algorithm than more than 1 time.

\section{Method}

To gather a good amount of data, we will be running each algorithm through 3 different datasets: one which was given to me with the scheduler, which has a mix of CPU, I/O blocked and mix of the two; another data file 500 instructions in total across multiple processes, and the last file with 10,000 instructions. 

For unbiased results with the Lottery Scheduler, it will be run through each dataset 10 times and applying Standard Deviation to the results to remove any anomalies. This will give a better mean and average across all the results, and more consistent data if it was actually implemented on a system. To 

\section{Test Constraints}

\section{Results}

\subsection{Fasted Job Completion}

\subsection{Idle Time}

\subsection{Mean Time}

\subsection{Context Switching}

\section{Conclusion}



\end{document}
